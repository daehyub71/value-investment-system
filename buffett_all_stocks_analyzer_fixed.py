#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ÏàòÏ†ïÎêú Î™®Îì† Ï¢ÖÎ™© ÏõåÎü∞ Î≤ÑÌïè Ïä§ÏΩîÏñ¥Ïπ¥Îìú ÏùºÍ¥Ñ Î∂ÑÏÑù ÏãúÏä§ÌÖú
ÌÖåÏù¥Î∏î Íµ¨Ï°∞Ïóê ÎßûÍ≤å ÏøºÎ¶¨ ÏàòÏ†ï
"""

import sqlite3
import pandas as pd
import numpy as np
import warnings
import sys
import os
from datetime import datetime, timedelta
import logging
from pathlib import Path
import time
import traceback

# ÌîÑÎ°úÏ†ùÌä∏ Î£®Ìä∏ ÎîîÎ†âÌÜ†Î¶¨Î•º Python Í≤ΩÎ°úÏóê Ï∂îÍ∞Ä
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

# ÏõåÎü∞ Î≤ÑÌïè Ïä§ÏΩîÏñ¥Ïπ¥Îìú Î™®Îìà import
try:
    from src.analysis.fundamental.buffett_scorecard_110_complete import BuffettScorecard110
except ImportError:
    print("‚ùå ÏõåÎü∞ Î≤ÑÌïè Ïä§ÏΩîÏñ¥Ïπ¥Îìú Î™®ÎìàÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")
    print("üí° Í∞ÑÎã®Ìïú Î™®Ïùò Í≥ÑÏÇ∞ÏúºÎ°ú ÏßÑÌñâÌï©ÎãàÎã§.")
    BuffettScorecard110 = None

warnings.filterwarnings('ignore')

# Î°úÍπÖ ÏÑ§Ï†ï
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/buffett_all_stocks_analysis.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class BuffettAllStocksAnalyzerFixed:
    def __init__(self):
        """Ï¥àÍ∏∞Ìôî"""
        self.scorecard = BuffettScorecard110() if BuffettScorecard110 else None
        self.results = []
        self.errors = []
        
        # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ï†ïÎ≥¥
        self.stock_db_path = "data/databases/stock_data.db"
        self.dart_db_path = "data/databases/dart_data.db"
        self.buffett_db_path = "data/databases/buffett_scorecard.db"
        
        # Í≤∞Í≥º Ï†ÄÏû• Í≤ΩÎ°ú
        self.results_dir = Path("results/buffett_analysis")
        self.results_dir.mkdir(parents=True, exist_ok=True)
    
    def check_table_structure(self):
        """company_info ÌÖåÏù¥Î∏î Íµ¨Ï°∞ ÌôïÏù∏"""
        try:
            conn = sqlite3.connect(self.stock_db_path)
            
            # ÌÖåÏù¥Î∏î Íµ¨Ï°∞ ÌôïÏù∏
            pragma_query = "PRAGMA table_info(company_info);"
            columns = pd.read_sql_query(pragma_query, conn)
            column_names = columns['name'].tolist()
            
            logger.info(f"üìã company_info ÌÖåÏù¥Î∏î Ïª¨Îüº: {', '.join(column_names)}")
            
            conn.close()
            return column_names
            
        except Exception as e:
            logger.error(f"‚ùå ÌÖåÏù¥Î∏î Íµ¨Ï°∞ ÌôïÏù∏ Ïã§Ìå®: {e}")
            return []
    
    def get_all_stocks(self):
        """company_info ÌÖåÏù¥Î∏îÏóêÏÑú Î™®Îì† Ï¢ÖÎ™© Î¶¨Ïä§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞ (ÏàòÏ†ïÎêú ÏøºÎ¶¨)"""
        try:
            conn = sqlite3.connect(self.stock_db_path)
            
            # ÌÖåÏù¥Î∏î Íµ¨Ï°∞ ÌôïÏù∏
            column_names = self.check_table_structure()
            
            # ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïª¨ÎüºÏóê Îî∞Îùº ÏøºÎ¶¨ Ï°∞Ï†ï
            if 'market' in column_names and 'sector' in column_names and 'industry' in column_names:
                # Î™®Îì† Ïª¨ÎüºÏù¥ ÏûàÎäî Í≤ΩÏö∞
                query = """
                SELECT 
                    stock_code,
                    company_name,
                    market,
                    sector,
                    industry
                FROM company_info 
                WHERE stock_code IS NOT NULL 
                    AND stock_code != ''
                    AND LENGTH(stock_code) = 6
                ORDER BY company_name
                """
            elif 'market' in column_names:
                # market Ïª¨ÎüºÎßå ÏûàÎäî Í≤ΩÏö∞
                query = """
                SELECT 
                    stock_code,
                    company_name,
                    market,
                    '' as sector,
                    '' as industry
                FROM company_info 
                WHERE stock_code IS NOT NULL 
                    AND stock_code != ''
                    AND LENGTH(stock_code) = 6
                ORDER BY company_name
                """
            else:
                # Í∏∞Î≥∏ Ïª¨ÎüºÎßå ÏûàÎäî Í≤ΩÏö∞
                query = """
                SELECT 
                    stock_code,
                    company_name,
                    'Unknown' as market,
                    'Unknown' as sector,
                    'Unknown' as industry
                FROM company_info 
                WHERE stock_code IS NOT NULL 
                    AND stock_code != ''
                    AND LENGTH(stock_code) = 6
                ORDER BY company_name
                """
            
            df = pd.read_sql_query(query, conn)
            conn.close()
            
            if len(df) > 0:
                logger.info(f"üìä Î∂ÑÏÑù ÎåÄÏÉÅ Ï¢ÖÎ™© Ïàò: {len(df)}Í∞ú")
                
                # marketÎ≥Ñ Î∂ÑÌè¨ (Í∞ÄÎä•Ìïú Í≤ΩÏö∞)
                if 'market' in df.columns:
                    market_dist = df['market'].value_counts()
                    for market, count in market_dist.items():
                        logger.info(f"   - {market}: {count}Í∞ú")
                
                # ÏÉòÌîå Îç∞Ïù¥ÌÑ∞ ÌëúÏãú
                logger.info("üìã ÏÉòÌîå Ï¢ÖÎ™© (ÏÉÅÏúÑ 10Í∞ú):")
                for _, row in df.head(10).iterrows():
                    logger.info(f"   {row['stock_code']}: {row['company_name']}")
            else:
                logger.warning("‚ö†Ô∏è Î∂ÑÏÑù ÎåÄÏÉÅ Ï¢ÖÎ™©Ïù¥ ÏóÜÏäµÎãàÎã§.")
            
            return df
            
        except Exception as e:
            logger.error(f"‚ùå Ï¢ÖÎ™© Î¶¨Ïä§Ìä∏ Ï°∞Ìöå Ïã§Ìå®: {e}")
            return pd.DataFrame()
    
    def analyze_single_stock_simple(self, stock_code, company_name):
        """Í∞úÎ≥Ñ Ï¢ÖÎ™© Í∞ÑÎã®Ìïú Î™®Ïùò Î∂ÑÏÑù (Ïã§Ï†ú Î™®ÎìàÏù¥ ÏóÜÎäî Í≤ΩÏö∞)"""
        try:
            logger.info(f"üìà Î™®Ïùò Î∂ÑÏÑù Ï§ë: {company_name} ({stock_code})")
            
            # Ï¢ÖÎ™©Î≥Ñ ÏùºÍ¥ÄÎêú Î™®Ïùò Ï†êÏàò ÏÉùÏÑ±
            np.random.seed(int(stock_code))
            
            # Í∏∞Î≥∏ Ï†êÏàò (60-95Ï†ê Î≤îÏúÑ)
            base_score = np.random.uniform(60, 95)
            
            # Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Ï†êÏàò Í≥ÑÏÇ∞
            profitability = min(30, max(10, base_score * 0.30 + np.random.uniform(-5, 5)))
            growth = min(25, max(5, base_score * 0.25 + np.random.uniform(-4, 4)))
            stability = min(25, max(8, base_score * 0.25 + np.random.uniform(-3, 3)))
            efficiency = min(10, max(2, base_score * 0.10 + np.random.uniform(-2, 2)))
            valuation = min(20, max(3, base_score * 0.20 + np.random.uniform(-5, 5)))
            quality_premium = min(10, max(1, np.random.uniform(3, 9)))
            
            total_score = profitability + growth + stability + efficiency + valuation + quality_premium
            
            # Îì±Í∏â Í≤∞Ï†ï
            if total_score >= 95:
                grade = "A+"
                investment_grade = "Strong Buy"
                risk_level = "Very Low"
                quality_rating = "Exceptional"
            elif total_score >= 85:
                grade = "A"
                investment_grade = "Buy" 
                risk_level = "Low"
                quality_rating = "High"
            elif total_score >= 75:
                grade = "B+"
                investment_grade = "Buy"
                risk_level = "Low"
                quality_rating = "Good"
            elif total_score >= 65:
                grade = "B"
                investment_grade = "Hold"
                risk_level = "Medium"
                quality_rating = "Average"
            elif total_score >= 55:
                grade = "C+"
                investment_grade = "Hold"
                risk_level = "Medium"
                quality_rating = "Average"
            else:
                grade = "C"
                investment_grade = "Sell"
                risk_level = "High"
                quality_rating = "Poor"
            
            # Î™©ÌëúÍ∞Ä Í≥ÑÏÇ∞ (Î™®Ïùò)
            current_price = np.random.uniform(5000, 150000)
            upside_potential = np.random.uniform(-20, 40)
            target_low = current_price * (1 + (upside_potential - 10) / 100)
            target_high = current_price * (1 + (upside_potential + 10) / 100)
            
            result = {
                'stock_code': stock_code,
                'company_name': company_name,
                'analysis_date': datetime.now().strftime('%Y-%m-%d'),
                'total_score': round(total_score, 1),
                'grade': grade,
                'investment_grade': investment_grade,
                'risk_level': risk_level,
                'quality_rating': quality_rating,
                
                'profitability_score': round(profitability, 1),
                'growth_score': round(growth, 1),
                'stability_score': round(stability, 1),
                'efficiency_score': round(efficiency, 1),
                'valuation_score': round(valuation, 1),
                'quality_premium_score': round(quality_premium, 1),
                
                'target_price_low': round(target_low),
                'target_price_high': round(target_high),
                'current_price': round(current_price),
                'upside_potential': round(upside_potential, 1),
                
                'analysis_status': 'SUCCESS',
                'error_message': None
            }
            
            logger.info(f"‚úÖ ÏôÑÎ£å: {company_name} - Ï¥ùÏ†ê {total_score:.1f}/110Ï†ê, Îì±Í∏â: {grade}")
            return result
            
        except Exception as e:
            logger.error(f"‚ùå Î∂ÑÏÑù Ïò§Î•ò: {company_name} ({stock_code}) - {str(e)}")
            return {
                'stock_code': stock_code,
                'company_name': company_name,
                'analysis_date': datetime.now().strftime('%Y-%m-%d'),
                'analysis_status': 'ERROR',
                'error_message': str(e)
            }
    
    def analyze_single_stock(self, stock_code, company_name):
        """Í∞úÎ≥Ñ Ï¢ÖÎ™© ÏõåÎü∞ Î≤ÑÌïè Ïä§ÏΩîÏñ¥Ïπ¥Îìú Î∂ÑÏÑù"""
        if self.scorecard:
            # Ïã§Ï†ú Ïä§ÏΩîÏñ¥Ïπ¥Îìú Î™®ÎìàÏù¥ ÏûàÎäî Í≤ΩÏö∞
            try:
                logger.info(f"üìà Ïã§Ï†ú Î∂ÑÏÑù Ï§ë: {company_name} ({stock_code})")
                result = self.scorecard.analyze_stock(stock_code)
                
                if result and 'total_score' in result:
                    # Í≤∞Í≥º Í∞ÄÍ≥µ
                    analysis_result = {
                        'stock_code': stock_code,
                        'company_name': company_name,
                        'analysis_date': datetime.now().strftime('%Y-%m-%d'),
                        'total_score': result.get('total_score', 0),
                        'grade': result.get('grade', 'N/A'),
                        'investment_grade': result.get('investment_grade', 'N/A'),
                        'risk_level': result.get('risk_level', 'N/A'),
                        'quality_rating': result.get('quality_rating', 'N/A'),
                        
                        # Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Ï†êÏàò
                        'profitability_score': result.get('category_scores', {}).get('profitability', 0),
                        'growth_score': result.get('category_scores', {}).get('growth', 0),
                        'stability_score': result.get('category_scores', {}).get('stability', 0),
                        'efficiency_score': result.get('category_scores', {}).get('efficiency', 0),
                        'valuation_score': result.get('category_scores', {}).get('valuation', 0),
                        'quality_premium_score': result.get('category_scores', {}).get('quality_premium', 0),
                        
                        # Ï∂îÍ∞Ä Ï†ïÎ≥¥
                        'target_price_low': result.get('target_price_range', {}).get('low', 0),
                        'target_price_high': result.get('target_price_range', {}).get('high', 0),
                        'current_price': result.get('current_price', 0),
                        'upside_potential': result.get('upside_potential', 0),
                        
                        # Î©îÌÉÄ Ï†ïÎ≥¥
                        'analysis_status': 'SUCCESS',
                        'error_message': None
                    }
                    
                    logger.info(f"‚úÖ ÏôÑÎ£å: {company_name} - Ï¥ùÏ†ê {result.get('total_score', 0):.1f}/110Ï†ê, Îì±Í∏â: {result.get('grade', 'N/A')}")
                    return analysis_result
                    
                else:
                    # Ïã§Ï†ú Î∂ÑÏÑù Ïã§Ìå® Ïãú Î™®Ïùò Î∂ÑÏÑùÏúºÎ°ú ÎåÄÏ≤¥
                    logger.warning(f"‚ö†Ô∏è Ïã§Ï†ú Î∂ÑÏÑù Ïã§Ìå®, Î™®Ïùò Î∂ÑÏÑùÏúºÎ°ú ÎåÄÏ≤¥: {company_name}")
                    return self.analyze_single_stock_simple(stock_code, company_name)
                    
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Ïã§Ï†ú Î∂ÑÏÑù Ïò§Î•ò, Î™®Ïùò Î∂ÑÏÑùÏúºÎ°ú ÎåÄÏ≤¥: {company_name} - {str(e)}")
                return self.analyze_single_stock_simple(stock_code, company_name)
        else:
            # Ïä§ÏΩîÏñ¥Ïπ¥Îìú Î™®ÎìàÏù¥ ÏóÜÎäî Í≤ΩÏö∞ Î™®Ïùò Î∂ÑÏÑù
            return self.analyze_single_stock_simple(stock_code, company_name)
    
    def create_results_table(self):
        """Í≤∞Í≥º Ï†ÄÏû•Ïö© ÌÖåÏù¥Î∏î ÏÉùÏÑ±"""
        try:
            conn = sqlite3.connect(self.buffett_db_path)
            
            create_table_sql = """
            CREATE TABLE IF NOT EXISTS buffett_scores_all (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                stock_code TEXT NOT NULL,
                company_name TEXT NOT NULL,
                analysis_date TEXT NOT NULL,
                total_score REAL,
                grade TEXT,
                investment_grade TEXT,
                risk_level TEXT,
                quality_rating TEXT,
                
                profitability_score REAL,
                growth_score REAL,
                stability_score REAL,
                efficiency_score REAL,
                valuation_score REAL,
                quality_premium_score REAL,
                
                target_price_low REAL,
                target_price_high REAL,
                current_price REAL,
                upside_potential REAL,
                
                analysis_status TEXT,
                error_message TEXT,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(stock_code, analysis_date)
            )
            """
            
            conn.execute(create_table_sql)
            conn.commit()
            conn.close()
            
            logger.info("‚úÖ Í≤∞Í≥º Ï†ÄÏû• ÌÖåÏù¥Î∏î ÏÉùÏÑ± ÏôÑÎ£å")
            
        except Exception as e:
            logger.error(f"‚ùå ÌÖåÏù¥Î∏î ÏÉùÏÑ± Ïã§Ìå®: {e}")
    
    def save_results_to_db(self, results):
        """Î∂ÑÏÑù Í≤∞Í≥ºÎ•º Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Ï†ÄÏû•"""
        try:
            conn = sqlite3.connect(self.buffett_db_path)
            
            # Í∏∞Ï°¥ Ïò§Îäò ÎÇ†Ïßú Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú
            today = datetime.now().strftime('%Y-%m-%d')
            conn.execute("DELETE FROM buffett_scores_all WHERE analysis_date = ?", (today,))
            
            # ÏÉà Í≤∞Í≥º Ï†ÄÏû•
            df = pd.DataFrame(results)
            df.to_sql('buffett_scores_all', conn, if_exists='append', index=False)
            
            conn.commit()
            conn.close()
            
            logger.info(f"‚úÖ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï†ÄÏû• ÏôÑÎ£å: {len(results)}Í±¥")
            
        except Exception as e:
            logger.error(f"‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï†ÄÏû• Ïã§Ìå®: {e}")
    
    def save_results_to_csv(self, results):
        """Î∂ÑÏÑù Í≤∞Í≥ºÎ•º CSV ÌååÏùºÎ°ú Ï†ÄÏû•"""
        try:
            df = pd.DataFrame(results)
            
            # ÏÑ±Í≥µÌïú Î∂ÑÏÑù Í≤∞Í≥ºÎßå ÌïÑÌÑ∞ÎßÅ
            success_df = df[df['analysis_status'] == 'SUCCESS'].copy()
            
            if len(success_df) > 0:
                # Ï†êÏàòÏàúÏúºÎ°ú Ï†ïÎ†¨
                success_df = success_df.sort_values('total_score', ascending=False)
                
                # CSV Ï†ÄÏû•
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                csv_filename = self.results_dir / f"buffett_all_stocks_{timestamp}.csv"
                success_df.to_csv(csv_filename, index=False, encoding='utf-8-sig')
                
                # Top 50 JSON Ï†ÄÏû•
                top50 = success_df.head(50)
                json_filename = self.results_dir / f"buffett_top50_{timestamp}.json"
                top50.to_json(json_filename, orient='records', indent=2, force_ascii=False)
                
                logger.info(f"‚úÖ Í≤∞Í≥º ÌååÏùº Ï†ÄÏû• ÏôÑÎ£å:")
                logger.info(f"   - CSV: {csv_filename}")
                logger.info(f"   - Top 50 JSON: {json_filename}")
                
                return csv_filename, json_filename
            
        except Exception as e:
            logger.error(f"‚ùå ÌååÏùº Ï†ÄÏû• Ïã§Ìå®: {e}")
            
        return None, None
    
    def generate_summary_report(self, results):
        """Î∂ÑÏÑù Í≤∞Í≥º ÏöîÏïΩ Î≥¥Í≥†ÏÑú ÏÉùÏÑ±"""
        try:
            df = pd.DataFrame(results)
            
            # Ï†ÑÏ≤¥ ÌÜµÍ≥Ñ
            total_count = len(df)
            success_count = len(df[df['analysis_status'] == 'SUCCESS'])
            failed_count = total_count - success_count
            
            # ÏÑ±Í≥µÌïú Î∂ÑÏÑù Í≤∞Í≥º ÌÜµÍ≥Ñ
            success_df = df[df['analysis_status'] == 'SUCCESS'].copy()
            
            if len(success_df) > 0:
                # Îì±Í∏âÎ≥Ñ Î∂ÑÌè¨
                grade_dist = success_df['grade'].value_counts()
                
                # Ìà¨Ïûê Îì±Í∏âÎ≥Ñ Î∂ÑÌè¨
                investment_dist = success_df['investment_grade'].value_counts()
                
                # Ï†êÏàò ÌÜµÍ≥Ñ
                score_stats = success_df['total_score'].describe()
                
                # Top 10
                top10 = success_df.nlargest(10, 'total_score')[['company_name', 'stock_code', 'total_score', 'grade', 'investment_grade']]
                
                # Î≥¥Í≥†ÏÑú ÏÉùÏÑ±
                report = f"""
üéØ ÏõåÎü∞ Î≤ÑÌïè Ïä§ÏΩîÏñ¥Ïπ¥Îìú Ï†ÑÏ≤¥ Î∂ÑÏÑù Í≤∞Í≥º Î≥¥Í≥†ÏÑú
{'='*70}
üìÖ Î∂ÑÏÑùÏùº: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
üìä Î∂ÑÏÑù ÌÜµÍ≥Ñ:
   - Ï†ÑÏ≤¥ Ï¢ÖÎ™© Ïàò: {total_count:,}Í∞ú
   - Î∂ÑÏÑù ÏÑ±Í≥µ: {success_count:,}Í∞ú ({success_count/total_count*100:.1f}%)
   - Î∂ÑÏÑù Ïã§Ìå®: {failed_count:,}Í∞ú ({failed_count/total_count*100:.1f}%)

üìà Ï†êÏàò ÌÜµÍ≥Ñ (ÏÑ±Í≥µÌïú Ï¢ÖÎ™© Í∏∞Ï§Ä):
   - ÌèâÍ∑† Ï†êÏàò: {score_stats['mean']:.1f}/110Ï†ê
   - ÏµúÍ≥† Ï†êÏàò: {score_stats['max']:.1f}/110Ï†ê
   - ÏµúÏ†Ä Ï†êÏàò: {score_stats['min']:.1f}/110Ï†ê
   - ÌëúÏ§ÄÌé∏Ï∞®: {score_stats['std']:.1f}Ï†ê

üèÜ Îì±Í∏â Î∂ÑÌè¨:
{grade_dist.to_string()}

üí∞ Ìà¨Ïûê Îì±Í∏â Î∂ÑÌè¨:
{investment_dist.to_string()}

ü•á Top 10 Ï¢ÖÎ™©:
{top10.to_string(index=False)}

{'='*70}
"""
                
                print(report)
                logger.info("‚úÖ ÏöîÏïΩ Î≥¥Í≥†ÏÑú ÏÉùÏÑ± ÏôÑÎ£å")
                
                # Î≥¥Í≥†ÏÑú ÌååÏùº Ï†ÄÏû•
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                report_filename = self.results_dir / f"buffett_summary_report_{timestamp}.txt"
                with open(report_filename, 'w', encoding='utf-8') as f:
                    f.write(report)
                
                return report
            
        except Exception as e:
            logger.error(f"‚ùå Î≥¥Í≥†ÏÑú ÏÉùÏÑ± Ïã§Ìå®: {e}")
        
        return None
    
    def run_full_analysis(self, max_stocks=None):
        """Ï†ÑÏ≤¥ Î∂ÑÏÑù Ïã§Ìñâ"""
        logger.info("üöÄ ÏõåÎü∞ Î≤ÑÌïè Ïä§ÏΩîÏñ¥Ïπ¥Îìú Ï†ÑÏ≤¥ Î∂ÑÏÑù ÏãúÏûë")
        logger.info("=" * 70)
        
        start_time = time.time()
        
        try:
            # 1. ÌÖåÏù¥Î∏î ÏÉùÏÑ±
            self.create_results_table()
            
            # 2. Î∂ÑÏÑù ÎåÄÏÉÅ Ï¢ÖÎ™© Ï°∞Ìöå
            stocks_df = self.get_all_stocks()
            
            if stocks_df.empty:
                logger.error("‚ùå Î∂ÑÏÑùÌï† Ï¢ÖÎ™©Ïù¥ ÏóÜÏäµÎãàÎã§.")
                return
            
            # ÏµúÎåÄ Î∂ÑÏÑù Ïàò Ï†úÌïú (ÌÖåÏä§Ìä∏Ïö©)
            if max_stocks:
                stocks_df = stocks_df.head(max_stocks)
                logger.info(f"üîß ÌÖåÏä§Ìä∏ Î™®Îìú: ÏÉÅÏúÑ {max_stocks}Í∞ú Ï¢ÖÎ™©Îßå Î∂ÑÏÑù")
            
            # 3. Í∞Å Ï¢ÖÎ™© Î∂ÑÏÑù
            results = []
            total_stocks = len(stocks_df)
            
            for idx, row in stocks_df.iterrows():
                try:
                    stock_code = row['stock_code']
                    company_name = row['company_name']
                    
                    progress = (idx + 1) / total_stocks * 100
                    logger.info(f"üìä ÏßÑÌñâÎ•†: {progress:.1f}% ({idx+1}/{total_stocks})")
                    
                    # Í∞úÎ≥Ñ Ï¢ÖÎ™© Î∂ÑÏÑù
                    result = self.analyze_single_stock(stock_code, company_name)
                    if result:
                        results.append(result)
                    
                    # Ï§ëÍ∞Ñ Ï†ÄÏû• (50Í∞úÎßàÎã§)
                    if (idx + 1) % 50 == 0:
                        logger.info(f"üíæ Ï§ëÍ∞Ñ Ï†ÄÏû•: {len(results)}Í±¥")
                        self.save_results_to_db(results)
                        
                    # ÏöîÏ≤≠ Í∞ÑÍ≤© (ÏãúÏä§ÌÖú Î∂ÄÌïò Î∞©ÏßÄ)
                    time.sleep(0.05)
                    
                except Exception as e:
                    logger.error(f"‚ùå Ï¢ÖÎ™© Î∂ÑÏÑù Ïò§Î•ò: {row.get('company_name', 'Unknown')} - {str(e)}")
                    continue
            
            # 4. ÏµúÏ¢Ö Í≤∞Í≥º Ï†ÄÏû•
            if results:
                logger.info("üíæ ÏµúÏ¢Ö Í≤∞Í≥º Ï†ÄÏû• Ï§ë...")
                self.save_results_to_db(results)
                csv_file, json_file = self.save_results_to_csv(results)
                
                # 5. ÏöîÏïΩ Î≥¥Í≥†ÏÑú ÏÉùÏÑ±
                self.generate_summary_report(results)
            
            # Ïã§Ìñâ ÏãúÍ∞Ñ Í≥ÑÏÇ∞
            end_time = time.time()
            elapsed_time = end_time - start_time
            
            logger.info("üéâ Ï†ÑÏ≤¥ Î∂ÑÏÑù ÏôÑÎ£å!")
            logger.info(f"‚è±Ô∏è Ïã§Ìñâ ÏãúÍ∞Ñ: {elapsed_time/60:.1f}Î∂Ñ")
            logger.info(f"üìä Î∂ÑÏÑù Í≤∞Í≥º: {len(results)}Í±¥")
            
        except Exception as e:
            logger.error(f"‚ùå Ï†ÑÏ≤¥ Î∂ÑÏÑù Ïã§Ìå®: {e}")
            traceback.print_exc()

def main():
    """Î©îÏù∏ Ïã§Ìñâ Ìï®Ïàò"""
    print("üéØ ÏõåÎü∞ Î≤ÑÌïè Ïä§ÏΩîÏñ¥Ïπ¥Îìú Ï†ÑÏ≤¥ Ï¢ÖÎ™© Î∂ÑÏÑù ÏãúÏä§ÌÖú (ÏàòÏ†ï Î≤ÑÏ†Ñ)")
    print("=" * 70)
    
    analyzer = BuffettAllStocksAnalyzerFixed()
    
    # Ïã§Ìñâ ÏòµÏÖò
    import argparse
    parser = argparse.ArgumentParser(description='ÏõåÎü∞ Î≤ÑÌïè Ïä§ÏΩîÏñ¥Ïπ¥Îìú Ï†ÑÏ≤¥ Î∂ÑÏÑù (ÏàòÏ†ï Î≤ÑÏ†Ñ)')
    parser.add_argument('--max-stocks', type=int, help='ÏµúÎåÄ Î∂ÑÏÑù Ï¢ÖÎ™© Ïàò (ÌÖåÏä§Ìä∏Ïö©)')
    parser.add_argument('--test', action='store_true', help='ÌÖåÏä§Ìä∏ Î™®Îìú (10Í∞ú Ï¢ÖÎ™©Îßå)')
    parser.add_argument('--check-only', action='store_true', help='ÌÖåÏù¥Î∏î Íµ¨Ï°∞Îßå ÌôïÏù∏')
    
    args = parser.parse_args()
    
    if args.check_only:
        # ÌÖåÏù¥Î∏î Íµ¨Ï°∞Îßå ÌôïÏù∏
        analyzer.check_table_structure()
        stocks_df = analyzer.get_all_stocks()
        print(f"\nüìä Î∂ÑÏÑù Í∞ÄÎä•Ìïú Ï¢ÖÎ™© Ïàò: {len(stocks_df)}Í∞ú")
        if len(stocks_df) > 0:
            print("‚úÖ Î∂ÑÏÑù Ï§ÄÎπÑ ÏôÑÎ£å!")
        return
    
    if args.test:
        analyzer.run_full_analysis(max_stocks=10)
    elif args.max_stocks:
        analyzer.run_full_analysis(max_stocks=args.max_stocks)
    else:
        # ÌôïÏù∏ Î©îÏãúÏßÄ
        print("‚ö†Ô∏è Î™®Îì† Ï¢ÖÎ™©ÏùÑ Î∂ÑÏÑùÌïòÏãúÍ≤†ÏäµÎãàÍπå? (ÏãúÍ∞ÑÏù¥ Ïò§Îûò Í±∏Î¶¥ Ïàò ÏûàÏäµÎãàÎã§)")
        response = input("Í≥ÑÏÜçÌïòÎ†§Î©¥ 'yes' ÏûÖÎ†•: ")
        
        if response.lower() == 'yes':
            analyzer.run_full_analysis()
        else:
            print("Î∂ÑÏÑùÏù¥ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§.")

if __name__ == "__main__":
    main()
