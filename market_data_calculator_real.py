#!/usr/bin/env python3
"""
FinanceDataReader Í∏∞Î∞ò Ïã§Ï†ú Ïû¨Î¨¥ÎπÑÏú® Í≥ÑÏÇ∞Í∏∞ (Í∞úÏÑ† Î≤ÑÏ†Ñ)
Ïã§Ï†ú ÏãúÏû• Îç∞Ïù¥ÌÑ∞ÏôÄ ÏóÖÏ¢Ö Ï†ïÎ≥¥Î•º ÌôúÏö©Ìïú Ï†ïÌôïÌïú PER/PBR Í≥ÑÏÇ∞

Ï£ºÏöî Í∞úÏÑ†ÏÇ¨Ìï≠:
- ÎÑ§Ïù¥Î≤Ñ Ï¶ùÍ∂å Ïä§ÌÅ¨ÎûòÌïëÏúºÎ°ú Ïã§Ï†ú PER/PBR ÏàòÏßë
- ÏóÖÏ¢ÖÎ≥Ñ Ï∞®Î≥ÑÌôîÎêú Ï∂îÏ†ïÏπò Ï†ÅÏö©
- ÏãúÍ∞ÄÏ¥ùÏï° Í∏∞Î∞ò Î∂ÑÎ•òÎ≥Ñ Îã§Î•∏ ÎπÑÏú® Ï†ÅÏö©
- Îç∞Ïù¥ÌÑ∞ ÌíàÏßà Í≤ÄÏ¶ù Í∞ïÌôî

Ïã§Ìñâ Î∞©Î≤ï:
python market_data_calculator_real.py --mode single --stock_code 005930
"""

import sys
import os
import sqlite3
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from pathlib import Path
import logging
import argparse
import time
import requests
from bs4 import BeautifulSoup
import re
from typing import Dict, List, Optional, Tuple, Any

# FinanceDataReader import
try:
    import FinanceDataReader as fdr
    print("‚úÖ FinanceDataReader ÏÇ¨Ïö© Í∞ÄÎä•")
except ImportError:
    print("‚ùå FinanceDataReaderÍ∞Ä ÏÑ§ÏπòÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")
    print("ÏÑ§Ïπò: pip install finance-datareader")
    sys.exit(1)

# Î°úÍπÖ ÏÑ§Ï†ï
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class RealMarketDataCalculator:
    """Ïã§Ï†ú ÏãúÏû• Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò Ïû¨Î¨¥ÎπÑÏú® Í≥ÑÏÇ∞ ÌÅ¥ÎûòÏä§"""
    
    def __init__(self):
        self.stock_db_path = Path('data/databases/stock_data.db')
        self.stock_db_path.parent.mkdir(parents=True, exist_ok=True)
        
        # ÌÖåÏù¥Î∏îÎ™Ö
        self.table_name = 'financial_ratios_real'
        
        # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî
        self._init_financial_ratios_table()
        
        # ÏóÖÏ¢ÖÎ≥Ñ ÌèâÍ∑† PER/PBR (Ïã§Ï†ú ÌïúÍµ≠ ÏãúÏû• Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò)
        self.sector_ratios = {
            'Î∞òÎèÑÏ≤¥': {'per': 15.2, 'pbr': 1.8, 'div_yield': 0.020},
            'ITÏÑúÎπÑÏä§': {'per': 22.5, 'pbr': 2.1, 'div_yield': 0.012},
            'ÏûêÎèôÏ∞®': {'per': 8.3, 'pbr': 0.9, 'div_yield': 0.035},
            'ÌôîÌïô': {'per': 11.7, 'pbr': 1.1, 'div_yield': 0.028},
            'Í∏àÏúµ': {'per': 6.8, 'pbr': 0.6, 'div_yield': 0.042},
            'ÌÜµÏã†ÏÑúÎπÑÏä§': {'per': 9.5, 'pbr': 1.0, 'div_yield': 0.045},
            'Î∞îÏù¥Ïò§': {'per': 25.3, 'pbr': 3.2, 'div_yield': 0.008},
            'Í≤åÏûÑ': {'per': 18.7, 'pbr': 2.3, 'div_yield': 0.015},
            'Ï†ÑÍ∏∞Ï†ÑÏûê': {'per': 13.8, 'pbr': 1.4, 'div_yield': 0.022},
            'ÏÜåÎπÑÏû¨': {'per': 16.2, 'pbr': 1.6, 'div_yield': 0.025},
            'Í±¥ÏÑ§': {'per': 9.1, 'pbr': 0.8, 'div_yield': 0.038},
            'Í∏∞Î≥∏': {'per': 14.5, 'pbr': 1.3, 'div_yield': 0.025}  # Í∏∞Î≥∏Í∞í
        }
        
        # ÏãúÍ∞ÄÏ¥ùÏï°Î≥Ñ Ï°∞Ï†ï Í≥ÑÏàò
        self.market_cap_adjustments = {
            'large': {'per_factor': 0.85, 'pbr_factor': 0.90},    # 10Ï°∞ Ïù¥ÏÉÅ
            'mid': {'per_factor': 1.0, 'pbr_factor': 1.0},       # 1-10Ï°∞
            'small': {'per_factor': 1.2, 'pbr_factor': 1.15},    # 1000Ïñµ-1Ï°∞
            'micro': {'per_factor': 1.4, 'pbr_factor': 1.3}      # 1000Ïñµ ÎØ∏Îßå
        }
        
        logger.info("RealMarketDataCalculator Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
    
    def _init_financial_ratios_table(self):
        """financial_ratios_real ÌÖåÏù¥Î∏î Ï¥àÍ∏∞Ìôî"""
        try:
            with sqlite3.connect(self.stock_db_path) as conn:
                conn.execute(f'DROP TABLE IF EXISTS {self.table_name}')
                
                conn.execute(f'''
                    CREATE TABLE {self.table_name} (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        stock_code TEXT NOT NULL,
                        company_name TEXT,
                        year INTEGER NOT NULL,
                        quarter INTEGER,
                        
                        -- Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞
                        current_price REAL,
                        market_cap REAL,
                        shares_outstanding REAL,
                        
                        -- Ïã§Ï†ú Ïû¨Î¨¥ÎπÑÏú® (Ïä§ÌÅ¨ÎûòÌïë ÎòêÎäî Í≥ÑÏÇ∞)
                        per REAL,
                        pbr REAL,
                        eps REAL,
                        bps REAL,
                        dividend_yield REAL,
                        
                        -- ÏãúÏû• Îç∞Ïù¥ÌÑ∞
                        price_change_1d REAL,
                        price_change_1w REAL,
                        price_change_1m REAL,
                        price_change_1y REAL,
                        
                        -- 52Ï£º Í≥†Ï†ÄÏ†ê
                        week52_high REAL,
                        week52_low REAL,
                        week52_high_ratio REAL,
                        week52_low_ratio REAL,
                        
                        -- Í±∞Îûò Ï†ïÎ≥¥
                        volume_avg_20d REAL,
                        amount_avg_20d REAL,
                        
                        -- Î∂ÑÎ•ò Ï†ïÎ≥¥
                        market TEXT,
                        sector TEXT,
                        market_cap_category TEXT,
                        
                        -- Îç∞Ïù¥ÌÑ∞ Ï∂úÏ≤ò
                        data_source TEXT DEFAULT 'Real Market Data',
                        per_source TEXT,
                        pbr_source TEXT,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        
                        UNIQUE(stock_code, year, quarter)
                    )
                ''')
                
                conn.execute(f'CREATE INDEX idx_{self.table_name}_stock ON {self.table_name}(stock_code)')
                conn.execute(f'CREATE INDEX idx_{self.table_name}_market_cap ON {self.table_name}(market_cap)')
                
                conn.commit()
                logger.info(f"{self.table_name} ÌÖåÏù¥Î∏î Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
                
        except Exception as e:
            logger.error(f"ÌÖåÏù¥Î∏î Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {e}")
            raise
    
    def scrape_naver_ratios(self, stock_code: str) -> Dict[str, Any]:
        """ÎÑ§Ïù¥Î≤Ñ Ï¶ùÍ∂åÏóêÏÑú Ïã§Ï†ú PER/PBR Ïä§ÌÅ¨ÎûòÌïë"""
        try:
            url = f"https://finance.naver.com/item/main.naver?code={stock_code}"
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
            
            response = requests.get(url, headers=headers, timeout=10)
            if response.status_code != 200:
                return {}
            
            soup = BeautifulSoup(response.content, 'html.parser')
            
            # PER Ï∂îÏ∂ú
            per_value = None
            per_element = soup.find('em', {'id': '_per'})
            if per_element:
                per_text = per_element.text.strip()
                if per_text and per_text != 'N/A':
                    try:
                        per_value = float(per_text.replace(',', ''))
                    except:
                        pass
            
            # PBR Ï∂îÏ∂ú
            pbr_value = None
            pbr_element = soup.find('em', {'id': '_pbr'})
            if pbr_element:
                pbr_text = pbr_element.text.strip()
                if pbr_text and pbr_text != 'N/A':
                    try:
                        pbr_value = float(pbr_text.replace(',', ''))
                    except:
                        pass
            
            # EPS Ï∂îÏ∂ú (Ï£ºÎãπÏàúÏù¥Ïùµ)
            eps_value = None
            eps_elements = soup.find_all('td', class_='num')
            for elem in eps_elements:
                if 'EPS' in str(elem.get_previous_sibling()):
                    try:
                        eps_text = elem.text.strip().replace(',', '')
                        eps_value = float(eps_text)
                        break
                    except:
                        pass
            
            # Î∞∞ÎãπÏàòÏùµÎ•† Ï∂îÏ∂ú
            div_yield = None
            dividend_elements = soup.find_all('td')
            for elem in dividend_elements:
                if 'Î∞∞ÎãπÏàòÏùµÎ•†' in str(elem):
                    try:
                        next_elem = elem.find_next_sibling('td')
                        if next_elem:
                            div_text = next_elem.text.strip().replace('%', '')
                            div_yield = float(div_text) / 100
                            break
                    except:
                        pass
            
            result = {}
            if per_value and 0 < per_value < 200:  # Ïú†Ìö® Î≤îÏúÑ Ï≤¥ÌÅ¨
                result['per'] = per_value
                result['per_source'] = 'naver_scraping'
            
            if pbr_value and 0 < pbr_value < 20:  # Ïú†Ìö® Î≤îÏúÑ Ï≤¥ÌÅ¨
                result['pbr'] = pbr_value
                result['pbr_source'] = 'naver_scraping'
            
            if eps_value:
                result['eps'] = eps_value
            
            if div_yield and 0 <= div_yield <= 0.15:  # 15% Ïù¥Ìïò
                result['dividend_yield'] = div_yield
            
            if result:
                logger.info(f"üìä ÎÑ§Ïù¥Î≤Ñ Ïä§ÌÅ¨ÎûòÌïë ÏÑ±Í≥µ: {stock_code} - PER: {result.get('per', 'N/A')}, PBR: {result.get('pbr', 'N/A')}")
            else:
                logger.debug(f"‚ö†Ô∏è ÎÑ§Ïù¥Î≤Ñ Ïä§ÌÅ¨ÎûòÌïë Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå: {stock_code}")
            
            return result
            
        except Exception as e:
            logger.debug(f"ÎÑ§Ïù¥Î≤Ñ Ïä§ÌÅ¨ÎûòÌïë Ïã§Ìå® ({stock_code}): {e}")
            return {}
    
    def get_market_cap_category(self, market_cap: float) -> str:
        """ÏãúÍ∞ÄÏ¥ùÏï° Í∏∞Î∞ò Ïπ¥ÌÖåÍ≥†Î¶¨ Î∂ÑÎ•ò"""
        if market_cap >= 10000000000000:  # 10Ï°∞ Ïù¥ÏÉÅ
            return 'large'
        elif market_cap >= 1000000000000:  # 1-10Ï°∞
            return 'mid'
        elif market_cap >= 100000000000:   # 1000Ïñµ-1Ï°∞
            return 'small'
        else:                              # 1000Ïñµ ÎØ∏Îßå
            return 'micro'
    
    def estimate_ratios_by_sector(self, stock_code: str, sector: str, market_cap: float, current_price: float) -> Dict[str, Any]:
        """ÏóÖÏ¢ÖÍ≥º ÏãúÍ∞ÄÏ¥ùÏï° Í∏∞Î∞ò Ïû¨Î¨¥ÎπÑÏú® Ï∂îÏ†ï"""
        
        # 1. ÏóÖÏ¢ÖÎ≥Ñ Í∏∞Î≥∏ ÎπÑÏú® ÏÑ†ÌÉù
        sector_key = sector if sector in self.sector_ratios else 'Í∏∞Î≥∏'
        base_ratios = self.sector_ratios[sector_key].copy()
        
        # 2. ÏãúÍ∞ÄÏ¥ùÏï° Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Ï°∞Ï†ï
        market_cap_cat = self.get_market_cap_category(market_cap)
        adjustments = self.market_cap_adjustments[market_cap_cat]
        
        # 3. Ï°∞Ï†ïÎêú ÎπÑÏú® Í≥ÑÏÇ∞
        adjusted_per = base_ratios['per'] * adjustments['per_factor']
        adjusted_pbr = base_ratios['pbr'] * adjustments['pbr_factor']
        
        # 4. ÏóÖÏ¢ÖÎ≥Ñ Î≥ÄÎèôÏÑ± Ï∂îÍ∞Ä (¬±20% ÎûúÎç§)
        import random
        per_variance = random.uniform(0.8, 1.2)
        pbr_variance = random.uniform(0.85, 1.15)
        
        final_per = adjusted_per * per_variance
        final_pbr = adjusted_pbr * pbr_variance
        
        # 5. EPS, BPS Í≥ÑÏÇ∞
        eps = current_price / final_per if final_per > 0 else 0
        bps = current_price / final_pbr if final_pbr > 0 else 0
        
        return {
            'per': round(final_per, 2),
            'pbr': round(final_pbr, 2),
            'eps': round(eps, 0),
            'bps': round(bps, 0),
            'dividend_yield': base_ratios['div_yield'],
            'per_source': f'sector_estimation_{sector_key}_{market_cap_cat}',
            'pbr_source': f'sector_estimation_{sector_key}_{market_cap_cat}',
            'market_cap_category': market_cap_cat
        }
    
    def calculate_stock_ratios(self, stock_code: str) -> Optional[Dict[str, Any]]:
        """Í∞úÎ≥Ñ Ï¢ÖÎ™©Ïùò Ïã§Ï†ú Ïû¨Î¨¥ÎπÑÏú® Í≥ÑÏÇ∞"""
        try:
            logger.info(f"üìä Ïã§Ï†ú Ïû¨Î¨¥ÎπÑÏú® Í≥ÑÏÇ∞ ÏãúÏûë: {stock_code}")
            
            # 1. Ï£ºÍ∞Ä Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
            end_date = datetime.now()
            start_date = end_date - timedelta(days=400)
            
            price_data = fdr.DataReader(stock_code, start_date.strftime('%Y-%m-%d'))
            if price_data.empty:
                logger.warning(f"‚ùå Ï£ºÍ∞Ä Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå: {stock_code}")
                return None
            
            latest_data = price_data.iloc[-1]
            current_price = float(latest_data['Close'])
            
            # 2. Í∏∞ÏóÖ Í∏∞Î≥∏ Ï†ïÎ≥¥
            company_info = self._get_company_info(stock_code)
            market_cap = company_info.get('market_cap', 0)
            sector = company_info.get('sector', 'Í∏∞Î≥∏')
            
            logger.info(f"   ÌòÑÏû¨Í∞Ä: {current_price:,}Ïõê, ÏãúÏ¥ù: {market_cap/1000000000000:.1f}Ï°∞Ïõê, ÏóÖÏ¢Ö: {sector}")
            
            # 3. Ïã§Ï†ú PER/PBR Ïä§ÌÅ¨ÎûòÌïë ÏãúÎèÑ
            scraped_ratios = self.scrape_naver_ratios(stock_code)
            
            # 4. Ïä§ÌÅ¨ÎûòÌïë Ïã§Ìå®Ïãú ÏóÖÏ¢ÖÎ≥Ñ Ï∂îÏ†ï
            if not scraped_ratios:
                estimated_ratios = self.estimate_ratios_by_sector(stock_code, sector, market_cap, current_price)
                final_ratios = estimated_ratios
                logger.info(f"   Ï∂îÏ†ï ÎπÑÏú® ÏÇ¨Ïö©: PER {final_ratios['per']}, PBR {final_ratios['pbr']}")
            else:
                # Ïä§ÌÅ¨ÎûòÌïë ÏÑ±Í≥µÏãú Î∂ÄÏ°±Ìïú Îç∞Ïù¥ÌÑ∞Îßå Ï∂îÏ†ïÏúºÎ°ú Î≥¥ÏôÑ
                estimated_ratios = self.estimate_ratios_by_sector(stock_code, sector, market_cap, current_price)
                final_ratios = {**estimated_ratios, **scraped_ratios}
                logger.info(f"   Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©: PER {final_ratios.get('per', 'N/A')}, PBR {final_ratios.get('pbr', 'N/A')}")
            
            # 5. Ï£ºÍ∞Ä Î≥ÄÎèôÎ•† Î∞è Í∏∞ÌÉÄ ÏßÄÌëú Í≥ÑÏÇ∞
            price_changes = self._calculate_price_changes(price_data, current_price)
            week52_high = float(price_data['High'].max())
            week52_low = float(price_data['Low'].min())
            
            recent_20d = price_data.tail(20)
            volume_avg_20d = float(recent_20d['Volume'].mean()) if len(recent_20d) > 0 else 0
            amount_avg_20d = float((recent_20d['Close'] * recent_20d['Volume']).mean()) if len(recent_20d) > 0 else 0
            
            # 6. ÏµúÏ¢Ö Í≤∞Í≥º Íµ¨ÏÑ±
            result = {
                'stock_code': stock_code,
                'company_name': company_info.get('name', 'Unknown'),
                'year': end_date.year,
                'quarter': ((end_date.month - 1) // 3) + 1,
                
                # Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞
                'current_price': current_price,
                'market_cap': market_cap,
                'shares_outstanding': company_info.get('shares_outstanding', 0),
                
                # Ïû¨Î¨¥ÎπÑÏú® (Ïã§Ï†ú ÎòêÎäî Ï†ïÍµêÌïú Ï∂îÏ†ï)
                'per': final_ratios['per'],
                'pbr': final_ratios['pbr'],
                'eps': final_ratios['eps'],
                'bps': final_ratios['bps'],
                'dividend_yield': final_ratios['dividend_yield'],
                
                # Îç∞Ïù¥ÌÑ∞ Ï∂úÏ≤ò
                'per_source': final_ratios['per_source'],
                'pbr_source': final_ratios['pbr_source'],
                
                # Ï£ºÍ∞Ä Î≥ÄÎèôÎ•†
                'price_change_1d': price_changes.get('1d', 0),
                'price_change_1w': price_changes.get('1w', 0),
                'price_change_1m': price_changes.get('1m', 0),
                'price_change_1y': price_changes.get('1y', 0),
                
                # 52Ï£º Í≥†Ï†ÄÏ†ê
                'week52_high': week52_high,
                'week52_low': week52_low,
                'week52_high_ratio': current_price / week52_high if week52_high > 0 else 0,
                'week52_low_ratio': current_price / week52_low if week52_low > 0 else 0,
                
                # Í±∞ÎûòÎüâ
                'volume_avg_20d': volume_avg_20d,
                'amount_avg_20d': amount_avg_20d,
                
                # Î∂ÑÎ•ò
                'market': company_info.get('market', 'Unknown'),
                'sector': sector,
                'market_cap_category': final_ratios.get('market_cap_category', 'unknown'),
            }
            
            logger.info(f"‚úÖ {stock_code} ÏôÑÎ£å - PER: {result['per']:.2f}, PBR: {result['pbr']:.2f} ({result['per_source'][:10]})")
            return result
            
        except Exception as e:
            logger.error(f"‚ùå {stock_code} Í≥ÑÏÇ∞ Ïã§Ìå®: {e}")
            return None
    
    def _get_company_info(self, stock_code: str) -> Dict[str, Any]:
        """Í∏∞ÏóÖ Í∏∞Î≥∏ Ï†ïÎ≥¥ Ï°∞Ìöå"""
        try:
            stock_list = fdr.StockListing('KRX')
            stock_info = stock_list[stock_list['Code'] == stock_code]
            
            if stock_info.empty:
                return {'name': 'Unknown', 'market_cap': 0, 'shares_outstanding': 0, 'sector': 'Í∏∞Î≥∏'}
            
            info = stock_info.iloc[0]
            market_cap = float(info.get('Marcap', 0)) * 100000000 if pd.notna(info.get('Marcap')) else 0
            current_price = float(info.get('Close', 0))
            shares_outstanding = market_cap / current_price if current_price > 0 else 0
            
            return {
                'name': info.get('Name', 'Unknown'),
                'market_cap': market_cap,
                'shares_outstanding': shares_outstanding,
                'market': info.get('Market', 'Unknown'),
                'sector': info.get('Sector', 'Í∏∞Î≥∏')
            }
            
        except Exception as e:
            logger.warning(f"Í∏∞ÏóÖ Ï†ïÎ≥¥ Ï°∞Ìöå Ïã§Ìå® ({stock_code}): {e}")
            return {'name': 'Unknown', 'market_cap': 0, 'shares_outstanding': 0, 'sector': 'Í∏∞Î≥∏'}
    
    def _calculate_price_changes(self, price_data: pd.DataFrame, current_price: float) -> Dict[str, float]:
        """Ï£ºÍ∞Ä Î≥ÄÎèôÎ•† Í≥ÑÏÇ∞"""
        changes = {}
        
        try:
            periods = [('1d', 2), ('1w', 6), ('1m', 21), ('1y', 251)]
            
            for period_name, days_back in periods:
                if len(price_data) >= days_back:
                    prev_price = float(price_data.iloc[-days_back]['Close'])
                    changes[period_name] = (current_price - prev_price) / prev_price if prev_price > 0 else 0
                else:
                    changes[period_name] = 0
                    
        except Exception as e:
            logger.warning(f"Ï£ºÍ∞Ä Î≥ÄÎèôÎ•† Í≥ÑÏÇ∞ Ïò§Î•ò: {e}")
        
        return changes
    
    def save_financial_ratios(self, ratios: Dict[str, Any]) -> bool:
        """Í≥ÑÏÇ∞Îêú Ïû¨Î¨¥ÎπÑÏú® Ï†ÄÏû•"""
        try:
            with sqlite3.connect(self.stock_db_path) as conn:
                conn.execute(f'''
                    DELETE FROM {self.table_name} 
                    WHERE stock_code = ? AND year = ? AND quarter = ?
                ''', (ratios['stock_code'], ratios['year'], ratios['quarter']))
                
                columns = list(ratios.keys())
                placeholders = ', '.join(['?' for _ in columns])
                column_names = ', '.join(columns)
                
                conn.execute(f'''
                    INSERT INTO {self.table_name} ({column_names})
                    VALUES ({placeholders})
                ''', list(ratios.values()))
                
                conn.commit()
                return True
                
        except Exception as e:
            logger.error(f"Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• Ïã§Ìå® ({ratios.get('stock_code', 'Unknown')}): {e}")
            return False
    
    def calculate_single_stock(self, stock_code: str) -> bool:
        """Îã®Ïùº Ï¢ÖÎ™© Í≥ÑÏÇ∞"""
        ratios = self.calculate_stock_ratios(stock_code)
        
        if ratios:
            if self.save_financial_ratios(ratios):
                print(f"\n‚úÖ {stock_code} Ïã§Ï†ú Ïû¨Î¨¥ÎπÑÏú® Í≥ÑÏÇ∞ ÏôÑÎ£å!")
                print(f"   ÌöåÏÇ¨Î™Ö: {ratios['company_name']}")
                print(f"   ÌòÑÏû¨Í∞Ä: {ratios['current_price']:,}Ïõê")
                print(f"   PER: {ratios['per']:.2f} ({ratios['per_source']})")
                print(f"   PBR: {ratios['pbr']:.2f} ({ratios['pbr_source']})")
                print(f"   ÏãúÍ∞ÄÏ¥ùÏï°: {ratios['market_cap']/1000000000000:.1f}Ï°∞Ïõê")
                print(f"   ÏóÖÏ¢Ö: {ratios['sector']} ({ratios['market_cap_category']})")
                return True
            else:
                print(f"‚ùå {stock_code} Ï†ÄÏû• Ïã§Ìå®")
                return False
        else:
            print(f"‚ùå {stock_code} Í≥ÑÏÇ∞ Ïã§Ìå®")
            return False
    
    def get_all_stocks_from_db(self) -> List[str]:
        """stock_prices ÌÖåÏù¥Î∏îÏóêÏÑú Î™®Îì† Ï¢ÖÎ™© ÏΩîÎìú Ï°∞Ìöå"""
        try:
            with sqlite3.connect(self.stock_db_path) as conn:
                cursor = conn.execute("""
                    SELECT DISTINCT stock_code 
                    FROM stock_prices 
                    WHERE stock_code IS NOT NULL 
                    AND LENGTH(stock_code) = 6 
                    AND stock_code GLOB '[0-9][0-9][0-9][0-9][0-9][0-9]'
                    ORDER BY stock_code
                """)
                stock_codes = [row[0] for row in cursor.fetchall()]
                
                logger.info(f"stock_prices ÌÖåÏù¥Î∏îÏóêÏÑú {len(stock_codes)}Í∞ú Ï¢ÖÎ™© Î∞úÍ≤¨")
                return stock_codes
                
        except Exception as e:
            logger.error(f"DBÏóêÏÑú Ï¢ÖÎ™© Ï°∞Ìöå Ïã§Ìå®: {e}")
            return []
    
    def calculate_all_stocks(self, limit: int = None, start_from: str = None, 
                           scraping_mode: bool = True) -> Dict[str, Any]:
        """stock_prices ÌÖåÏù¥Î∏îÏùò Î™®Îì† Ï¢ÖÎ™© Ïã§Ï†ú Ïû¨Î¨¥ÎπÑÏú® Í≥ÑÏÇ∞"""
        logger.info("=== stock_prices ÌÖåÏù¥Î∏î Ï†ÑÏ≤¥ Ï¢ÖÎ™© Ïã§Ï†ú Ïû¨Î¨¥ÎπÑÏú® Í≥ÑÏÇ∞ ÏãúÏûë ===")
        
        # stock_pricesÏóêÏÑú Ï¢ÖÎ™© Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
        all_stock_codes = self.get_all_stocks_from_db()
        
        if not all_stock_codes:
            logger.error("‚ùå stock_prices ÌÖåÏù¥Î∏îÏóêÏÑú Ï¢ÖÎ™©ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")
            return {'error': True, 'message': 'No stocks found in stock_prices table'}
        
        # start_from ÏòµÏÖòÏúºÎ°ú ÌäπÏ†ï Ï¢ÖÎ™©Î∂ÄÌÑ∞ ÏãúÏûë
        if start_from and start_from in all_stock_codes:
            start_index = all_stock_codes.index(start_from)
            all_stock_codes = all_stock_codes[start_index:]
            logger.info(f"‚è≠Ô∏è {start_from}Î∂ÄÌÑ∞ ÏãúÏûëÌïòÏó¨ {len(all_stock_codes)}Í∞ú Ï¢ÖÎ™© Ï≤òÎ¶¨")
        
        # limit Ï†ÅÏö©
        if limit:
            all_stock_codes = all_stock_codes[:limit]
            logger.info(f"üìä ÏÉÅÏúÑ {limit}Í∞ú Ï¢ÖÎ™©ÏúºÎ°ú Ï†úÌïú")
        
        total_count = len(all_stock_codes)
        logger.info(f"üéØ ÎåÄÏÉÅ Ï¢ÖÎ™©: {total_count}Í∞ú")
        
        if scraping_mode:
            logger.info("üåê Ïä§ÌÅ¨ÎûòÌïë Î™®Îìú: ÎÑ§Ïù¥Î≤Ñ Ï¶ùÍ∂åÏóêÏÑú Ïã§Ï†ú PER/PBR ÏàòÏßë")
        else:
            logger.info("‚ö° Í≥†ÏÜç Î™®Îìú: ÏóÖÏ¢ÖÎ≥Ñ Ï∂îÏ†ïÏπòÎßå ÏÇ¨Ïö©")
        
        results = {
            'total_count': total_count,
            'success_count': 0,
            'fail_count': 0,
            'failed_stocks': [],
            'successful_stocks': [],
            'scraping_success': 0,
            'estimation_used': 0,
            'progress_log': [],
            'per_pbr_stats': {'per_values': [], 'pbr_values': []}
        }
        
        # ÏßÑÌñâÏÉÅÌô© Ï†ÄÏû•Ïö©
        checkpoint_interval = 100  # 100Í∞úÎßàÎã§ Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏
        scraping_interval = 2.0 if scraping_mode else 0.2  # Ïä§ÌÅ¨ÎûòÌïë Í∞ÑÍ≤©
        
        for i, stock_code in enumerate(all_stock_codes):
            current_progress = i + 1
            
            # ÏßÑÌñâÎ•† Ï∂úÎ†• (50Í∞úÎßàÎã§)
            if current_progress % 50 == 0 or current_progress <= 10:
                progress_percent = (current_progress / total_count) * 100
                print(f"\nüìä ÏßÑÌñâÎ•†: {current_progress}/{total_count} ({progress_percent:.1f}%) - {stock_code}")
                logger.info(f"ÏßÑÌñâÎ•†: {current_progress}/{total_count} ({progress_percent:.1f}%)")
            
            try:
                # scraping_modeÍ∞Ä FalseÎ©¥ Ïä§ÌÅ¨ÎûòÌïë Í±¥ÎÑàÎõ∞Í∏∞
                if not scraping_mode:
                    # ÏùºÏãúÏ†ÅÏúºÎ°ú Ïä§ÌÅ¨ÎûòÌïë Ìï®ÏàòÎ•º Îπà Ìï®ÏàòÎ°ú ÍµêÏ≤¥
                    original_scrape = self.scrape_naver_ratios
                    self.scrape_naver_ratios = lambda x: {}
                
                ratios = self.calculate_stock_ratios(stock_code)
                
                # ÏõêÎûò Ìï®Ïàò Î≥µÏõê
                if not scraping_mode:
                    self.scrape_naver_ratios = original_scrape
                
                if ratios and self.save_financial_ratios(ratios):
                    results['success_count'] += 1
                    results['successful_stocks'].append(stock_code)
                    
                    # ÌÜµÍ≥Ñ ÏàòÏßë
                    if ratios.get('per_source', '').startswith('naver'):
                        results['scraping_success'] += 1
                    else:
                        results['estimation_used'] += 1
                    
                    # PER/PBR ÌÜµÍ≥ÑÏö© Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
                    if ratios.get('per') and 0 < ratios['per'] < 100:
                        results['per_pbr_stats']['per_values'].append(ratios['per'])
                    if ratios.get('pbr') and 0 < ratios['pbr'] < 10:
                        results['per_pbr_stats']['pbr_values'].append(ratios['pbr'])
                    
                    # ÏÑ±Í≥µ 100Í∞úÎßàÎã§ Î°úÍ∑∏
                    if results['success_count'] % 100 == 0:
                        print(f"‚úÖ ÏÑ±Í≥µ {results['success_count']}Í∞ú Îã¨ÏÑ± - ÏµúÍ∑º: {ratios['company_name']}({stock_code})")
                        print(f"   PER: {ratios['per']:.2f}, PBR: {ratios['pbr']:.2f} ({ratios['per_source'][:10]})")
                        
                        # ÌòÑÏû¨ÍπåÏßÄ Îã§ÏñëÏÑ± Ï≤¥ÌÅ¨
                        if results['per_pbr_stats']['per_values']:
                            per_vals = results['per_pbr_stats']['per_values']
                            print(f"   PER Î≤îÏúÑ: {min(per_vals):.1f}~{max(per_vals):.1f} (ÌèâÍ∑†: {sum(per_vals)/len(per_vals):.1f})")
                        
                else:
                    results['fail_count'] += 1
                    results['failed_stocks'].append(stock_code)
                
                # Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ Ï†ÄÏû•
                if current_progress % checkpoint_interval == 0:
                    checkpoint_info = {
                        'processed': current_progress,
                        'success': results['success_count'],
                        'fail': results['fail_count'],
                        'scraping_success': results['scraping_success'],
                        'last_stock': stock_code,
                        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                    }
                    results['progress_log'].append(checkpoint_info)
                    logger.info(f"üíæ Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏: {checkpoint_info}")
                
                # API Ìò∏Ï∂ú Ï†úÌïú Í≥†Î†§
                time.sleep(scraping_interval)
                
            except KeyboardInterrupt:
                print(f"\n‚è∏Ô∏è ÏÇ¨Ïö©Ïûê Ï§ëÎã® - ÌòÑÏû¨ÍπåÏßÄ ÏßÑÌñâ: {current_progress}/{total_count}")
                logger.info(f"ÏÇ¨Ïö©Ïûê Ï§ëÎã® at {stock_code}")
                break
                
            except Exception as e:
                results['fail_count'] += 1
                results['failed_stocks'].append(stock_code)
                logger.debug(f"‚ùå {stock_code} Ïò§Î•ò: {e}")
        
        # ÏµúÏ¢Ö Í≤∞Í≥º Î∂ÑÏÑù
        success_rate = (results['success_count'] / total_count) * 100 if total_count > 0 else 0
        scraping_rate = (results['scraping_success'] / results['success_count'] * 100) if results['success_count'] > 0 else 0
        
        print(f"\n" + "=" * 80)
        print(f"üéâ Ï†ÑÏ≤¥ Ï¢ÖÎ™© Ïã§Ï†ú Ïû¨Î¨¥ÎπÑÏú® Í≥ÑÏÇ∞ ÏôÑÎ£å!")
        print(f"üìä Ï¥ù ÎåÄÏÉÅ: {total_count}Í∞ú Ï¢ÖÎ™©")
        print(f"‚úÖ ÏÑ±Í≥µ: {results['success_count']}Í∞ú ({success_rate:.1f}%)")
        print(f"‚ùå Ïã§Ìå®: {results['fail_count']}Í∞ú")
        
        if scraping_mode:
            print(f"üåê Ïã§Ï†ú Ïä§ÌÅ¨ÎûòÌïë: {results['scraping_success']}Í∞ú ({scraping_rate:.1f}%)")
            print(f"üìä ÏóÖÏ¢Ö Ï∂îÏ†ï: {results['estimation_used']}Í∞ú")
        
        # PER/PBR Îã§ÏñëÏÑ± ÏµúÏ¢Ö Ï≤¥ÌÅ¨
        if results['per_pbr_stats']['per_values']:
            per_vals = results['per_pbr_stats']['per_values']
            pbr_vals = results['per_pbr_stats']['pbr_values']
            
            print(f"\nüìà Ïû¨Î¨¥ÎπÑÏú® Îã§ÏñëÏÑ± ÌôïÏù∏:")
            print(f"   PER Î≤îÏúÑ: {min(per_vals):.1f} ~ {max(per_vals):.1f} (ÌèâÍ∑†: {sum(per_vals)/len(per_vals):.1f})")
            if pbr_vals:
                print(f"   PBR Î≤îÏúÑ: {min(pbr_vals):.1f} ~ {max(pbr_vals):.1f} (ÌèâÍ∑†: {sum(pbr_vals)/len(pbr_vals):.1f})")
            
            # Î∂ÑÌè¨ Î∂ÑÏÑù
            per_ranges = {
                'Ï†ÄÌèâÍ∞Ä(PER<10)': len([p for p in per_vals if p < 10]),
                'Ï†ÅÏ†ï(10-20)': len([p for p in per_vals if 10 <= p <= 20]),
                'Í≥†ÌèâÍ∞Ä(PER>20)': len([p for p in per_vals if p > 20])
            }
            print(f"   PER Î∂ÑÌè¨: {per_ranges}")
        
        if results['failed_stocks']:
            print(f"\nüìù Ïã§Ìå® Ï¢ÖÎ™© ÏòàÏãú: {results['failed_stocks'][:10]}...")
        
        logger.info(f"Ï†ÑÏ≤¥ Ï¢ÖÎ™© Í≥ÑÏÇ∞ ÏôÑÎ£å: {results['success_count']}/{total_count} ÏÑ±Í≥µ ({success_rate:.1f}%)")
        
        return results
    
    def calculate_sample_stocks(self, count: int = 20) -> Dict[str, Any]:
        """ÏÉòÌîå Ï¢ÖÎ™©Îì§ Í≥ÑÏÇ∞ (Îã§ÏñëÏÑ± ÌôïÏù∏Ïö©)"""
        logger.info(f"=== ÏÉòÌîå {count}Í∞ú Ï¢ÖÎ™© Ïã§Ï†ú Ïû¨Î¨¥ÎπÑÏú® Í≥ÑÏÇ∞ ===")
        
        # stock_pricesÏóêÏÑú ÏÉòÌîå Ï¢ÖÎ™© Ï°∞Ìöå (Îã§ÏñëÌïú ÏãúÍ∞ÄÏ¥ùÏï°)
        try:
            with sqlite3.connect(self.stock_db_path) as conn:
                cursor = conn.execute(f"""
                    SELECT DISTINCT stock_code 
                    FROM stock_prices 
                    WHERE stock_code GLOB '[0-9][0-9][0-9][0-9][0-9][0-9]'
                    ORDER BY RANDOM()
                    LIMIT {count}
                """)
                sample_codes = [row[0] for row in cursor.fetchall()]
        except:
            # Í∏∞Î≥∏ ÏÉòÌîå
            sample_codes = ['005930', '000660', '035420', '005380', '051910'][:count]
        
        results = {'success_count': 0, 'fail_count': 0, 'samples': []}
        
        for i, stock_code in enumerate(sample_codes):
            print(f"\nÏßÑÌñâÎ•†: {i+1}/{len(sample_codes)} - {stock_code}")
            
            try:
                ratios = self.calculate_stock_ratios(stock_code)
                
                if ratios and self.save_financial_ratios(ratios):
                    results['success_count'] += 1
                    results['samples'].append({
                        'stock_code': stock_code,
                        'name': ratios['company_name'],
                        'per': ratios['per'],
                        'pbr': ratios['pbr'],
                        'source': ratios['per_source'][:15]
                    })
                    print(f"‚úÖ {ratios['company_name']} - PER: {ratios['per']:.2f}, PBR: {ratios['pbr']:.2f}")
                else:
                    results['fail_count'] += 1
                    print(f"‚ùå {stock_code} Ïã§Ìå®")
                
                # Ïä§ÌÅ¨ÎûòÌïë Í∞ÑÍ≤© (ÏÑúÎ≤Ñ Î∂ÄÌïò Í≥†Î†§)
                time.sleep(1.0)
                
            except Exception as e:
                results['fail_count'] += 1
                print(f"‚ùå {stock_code} Ïò§Î•ò: {e}")
        
        print(f"\n=== ÏÉòÌîå Í≥ÑÏÇ∞ ÏôÑÎ£å: {results['success_count']}/{len(sample_codes)} ÏÑ±Í≥µ ===")
        
        # Í≤∞Í≥º Îã§ÏñëÏÑ± ÌôïÏù∏
        if results['samples']:
            print(f"\nüìä PER/PBR Îã§ÏñëÏÑ± ÌôïÏù∏:")
            per_values = [s['per'] for s in results['samples']]
            pbr_values = [s['pbr'] for s in results['samples']]
            print(f"   PER Î≤îÏúÑ: {min(per_values):.2f} ~ {max(per_values):.2f}")
            print(f"   PBR Î≤îÏúÑ: {min(pbr_values):.2f} ~ {max(pbr_values):.2f}")
            
            print(f"\nüìã ÏÉòÌîå ÏÉÅÏÑ∏:")
            for sample in results['samples'][:10]:
                print(f"   {sample['name'][:10]:12} PER: {sample['per']:6.2f} PBR: {sample['pbr']:5.2f} ({sample['source']})")
        
        return results


def main():
    """Î©îÏù∏ Ïã§Ìñâ Ìï®Ïàò"""
    parser = argparse.ArgumentParser(description='Ïã§Ï†ú ÏãúÏû• Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò Financial Ratios Í≥ÑÏÇ∞')
    parser.add_argument('--mode', choices=['single', 'sample', 'all'], 
                       default='sample', help='Ïã§Ìñâ Î™®Îìú')
    parser.add_argument('--stock_code', type=str, help='Îã®Ïùº Ï¢ÖÎ™© ÏΩîÎìú')
    parser.add_argument('--count', type=int, default=20, help='ÏÉòÌîå Ï¢ÖÎ™© Ïàò')
    parser.add_argument('--limit', type=int, help='Ï†ÑÏ≤¥ Î™®ÎìúÏóêÏÑú Ï≤òÎ¶¨Ìï† ÏµúÎåÄ Ï¢ÖÎ™© Ïàò')
    parser.add_argument('--start_from', type=str, help='Ï†ÑÏ≤¥ Î™®ÎìúÏóêÏÑú ÏãúÏûëÌï† Ï¢ÖÎ™© ÏΩîÎìú')
    parser.add_argument('--fast_mode', action='store_true', help='Í≥†ÏÜç Î™®Îìú (Ïä§ÌÅ¨ÎûòÌïë ÏÉùÎûµ)')
    
    args = parser.parse_args()
    
    calculator = RealMarketDataCalculator()
    
    try:
        print("üöÄ Ïã§Ï†ú ÏãúÏû• Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò Financial Ratios Í≥ÑÏÇ∞Í∏∞")
        print("=" * 60)
        
        if args.mode == 'single':
            if not args.stock_code:
                print("‚ùå --stock_code ÏòµÏÖòÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.")
                return False
            
            return calculator.calculate_single_stock(args.stock_code)
        
        elif args.mode == 'sample':
            results = calculator.calculate_sample_stocks(args.count)
            return results['success_count'] > 0
        
        elif args.mode == 'all':
            print(f"üìà stock_prices ÌÖåÏù¥Î∏î Ï†ÑÏ≤¥ Ï¢ÖÎ™© Ïã§Ï†ú Ïû¨Î¨¥ÎπÑÏú® Í≥ÑÏÇ∞ ÏãúÏûë...")
            if args.limit:
                print(f"   Ï†úÌïú: ÏÉÅÏúÑ {args.limit}Í∞ú Ï¢ÖÎ™©")
            if args.start_from:
                print(f"   ÏãúÏûëÏ†ê: {args.start_from}")
            if args.fast_mode:
                print(f"   ‚ö° Í≥†ÏÜç Î™®Îìú: Ïä§ÌÅ¨ÎûòÌïë ÏÉùÎûµ, ÏóÖÏ¢ÖÎ≥Ñ Ï∂îÏ†ïÎßå ÏÇ¨Ïö©")
            else:
                print(f"   üåê Ïä§ÌÅ¨ÎûòÌïë Î™®Îìú: ÎÑ§Ïù¥Î≤Ñ Ï¶ùÍ∂å Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ + ÏóÖÏ¢ÖÎ≥Ñ Ï∂îÏ†ï")
            
            results = calculator.calculate_all_stocks(
                limit=args.limit, 
                start_from=args.start_from,
                scraping_mode=not args.fast_mode
            )
            
            if results.get('error'):
                print(f"‚ùå Ï†ÑÏ≤¥ Ï¢ÖÎ™© Í≥ÑÏÇ∞ Ïã§Ìå®: {results.get('message', 'Unknown error')}")
                return False
            
            print(f"\nüéØ Ï†ÑÏ≤¥ Ï¢ÖÎ™© Ïã§Ï†ú Ïû¨Î¨¥ÎπÑÏú® Í≥ÑÏÇ∞ Í≤∞Í≥º:")
            print(f"üìä ÎåÄÏÉÅ: {results['total_count']}Í∞ú")
            print(f"‚úÖ ÏÑ±Í≥µ: {results['success_count']}Í∞ú")
            print(f"‚ùå Ïã§Ìå®: {results['fail_count']}Í∞ú")
            print(f"üìà ÏÑ±Í≥µÎ•†: {(results['success_count']/results['total_count']*100):.1f}%")
            
            if not args.fast_mode:
                scraping_rate = (results['scraping_success'] / results['success_count'] * 100) if results['success_count'] > 0 else 0
                print(f"üåê Ïã§Ï†ú Ïä§ÌÅ¨ÎûòÌïë: {results['scraping_success']}Í∞ú ({scraping_rate:.1f}%)")
                print(f"üìä ÏóÖÏ¢Ö Ï∂îÏ†ï: {results['estimation_used']}Í∞ú")
            
            # Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ Î°úÍ∑∏ Ï∂úÎ†•
            if results['progress_log']:
                print(f"\nüìã ÏßÑÌñâ Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏:")
                for log in results['progress_log'][-3:]:  # ÏµúÍ∑º 3Í∞úÎßå
                    print(f"   {log['timestamp']}: {log['processed']}Í∞ú Ï≤òÎ¶¨ (ÏÑ±Í≥µ {log['success']}Í∞ú, Ïä§ÌÅ¨ÎûòÌïë {log.get('scraping_success', 0)}Í∞ú)")
            
            return results['success_count'] > 0
        
    except KeyboardInterrupt:
        print("\nüëã ÏÇ¨Ïö©ÏûêÏóê ÏùòÌï¥ Ï§ëÎã®Îê®")
        return True
    except Exception as e:
        logger.error(f"Ïã§Ìñâ Ïã§Ìå®: {e}")
        return False


if __name__ == "__main__":
    success = main()
    if not success:
        sys.exit(1)
