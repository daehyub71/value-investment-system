#!/usr/bin/env python3
"""
ÏàòÏ†ïÎêú DART Ïû¨Î¨¥Îç∞Ïù¥ÌÑ∞ ÏàòÏßëÍ∏∞
Config import Ïò§Î•ò Ìï¥Í≤∞ Î∞è Îã®ÏàúÌôîÎêú Î≤ÑÏ†Ñ

Ïã§Ìñâ ÏòàÏãú:
python fixed_dart_collector.py --year=2023 --companies=10
python fixed_dart_collector.py --year=2022,2023 --companies=100
"""

import os
import sys
import time
import requests
import pandas as pd
import sqlite3
import xml.etree.ElementTree as ET
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, Any, List, Tuple
import logging
import zipfile
import io
from dotenv import load_dotenv

# ÌôòÍ≤ΩÎ≥ÄÏàò Î°úÎìú
load_dotenv()

class DartCollectorFixed:
    """ÏàòÏ†ïÎêú DART ÏàòÏßëÍ∏∞"""
    
    def __init__(self, request_delay: float = 1.5):
        self.logger = self.setup_logging()
        
        # API ÏÑ§Ï†ï (ÌôòÍ≤ΩÎ≥ÄÏàòÏóêÏÑú ÏßÅÏ†ë Î°úÎìú)
        self.api_key = os.getenv('DART_API_KEY')
        self.base_url = "https://opendart.fss.or.kr/api"
        
        if not self.api_key:
            raise ValueError("DART_API_KEY ÌôòÍ≤ΩÎ≥ÄÏàòÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")
        
        self.request_delay = request_delay
        self.session = requests.Session()
        self.stock_to_corp_mapping = {}
        
        # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í≤ΩÎ°ú
        self.db_path = Path('data/databases')
        self.dart_db_path = self.db_path / 'dart_data.db'
        self.stock_db_path = self.db_path / 'stock_data.db'
        
        # ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
        self.db_path.mkdir(parents=True, exist_ok=True)
        
        self.logger.info("‚úÖ DART ÏàòÏßëÍ∏∞ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
    
    def setup_logging(self):
        """Î°úÍπÖ ÏÑ§Ï†ï"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        return logging.getLogger('DartCollectorFixed')
    
    def init_dart_database(self):
        """DART Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî"""
        try:
            with sqlite3.connect(self.dart_db_path) as conn:
                # corp_codes ÌÖåÏù¥Î∏î
                conn.execute('''
                    CREATE TABLE IF NOT EXISTS corp_codes (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        corp_code TEXT UNIQUE NOT NULL,
                        corp_name TEXT NOT NULL,
                        stock_code TEXT,
                        modify_date TEXT,
                        created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                        updated_at TEXT DEFAULT CURRENT_TIMESTAMP
                    )
                ''')
                
                # financial_statements ÌÖåÏù¥Î∏î
                conn.execute('''
                    CREATE TABLE IF NOT EXISTS financial_statements (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        corp_code TEXT NOT NULL,
                        stock_code TEXT,
                        company_name TEXT,
                        bsns_year TEXT NOT NULL,
                        reprt_code TEXT NOT NULL,
                        account_nm TEXT,
                        account_id TEXT,
                        fs_div TEXT,
                        fs_nm TEXT,
                        sj_div TEXT,
                        sj_nm TEXT,
                        thstrm_nm TEXT,
                        thstrm_amount TEXT,
                        thstrm_add_amount TEXT,
                        frmtrm_nm TEXT,
                        frmtrm_amount TEXT,
                        frmtrm_q_nm TEXT,
                        frmtrm_q_amount TEXT,
                        frmtrm_add_amount TEXT,
                        bfefrmtrm_nm TEXT,
                        bfefrmtrm_amount TEXT,
                        ord INTEGER,
                        currency TEXT,
                        created_at TEXT DEFAULT CURRENT_TIMESTAMP
                    )
                ''')
                
                # Ïù∏Îç±Ïä§ ÏÉùÏÑ±
                conn.execute('''
                    CREATE INDEX IF NOT EXISTS idx_financial_corp_year 
                    ON financial_statements(corp_code, bsns_year)
                ''')
                
                conn.execute('''
                    CREATE INDEX IF NOT EXISTS idx_financial_stock_year 
                    ON financial_statements(stock_code, bsns_year)
                ''')
                
                conn.commit()
                self.logger.info("‚úÖ DART Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
                return True
                
        except Exception as e:
            self.logger.error(f"‚ùå DART Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {e}")
            return False
    
    def download_corp_codes(self) -> bool:
        """DART corp_codes.xml Îã§Ïö¥Î°úÎìú"""
        try:
            self.logger.info("üì° DART corp_codes.xml Îã§Ïö¥Î°úÎìú Ï§ë...")
            
            url = f"{self.base_url}/corpCode.xml"
            params = {'crtfc_key': self.api_key}
            
            response = self.session.get(url, params=params, timeout=30)
            response.raise_for_status()
            
            # ZIP ÌååÏùº Ï≤òÎ¶¨
            with zipfile.ZipFile(io.BytesIO(response.content)) as zip_file:
                xml_content = zip_file.read('CORPCODE.xml')
            
            # XML ÌååÏã±
            root = ET.fromstring(xml_content)
            
            self.logger.info("üîç corp_codes.xml ÌååÏã± Ï§ë...")
            
            mapping_count = 0
            for corp in root.findall('list'):
                corp_code = corp.find('corp_code').text if corp.find('corp_code') is not None else None
                stock_code = corp.find('stock_code').text if corp.find('stock_code') is not None else None
                corp_name = corp.find('corp_name').text if corp.find('corp_name') is not None else None
                
                if corp_code and stock_code and stock_code.strip():
                    self.stock_to_corp_mapping[stock_code.strip()] = {
                        'corp_code': corp_code.strip(),
                        'corp_name': corp_name.strip() if corp_name else ''
                    }
                    mapping_count += 1
            
            self.logger.info(f"‚úÖ Îß§Ìïë ÌÖåÏù¥Î∏î ÏÉùÏÑ± ÏôÑÎ£å: {mapping_count:,}Í∞ú ÏÉÅÏû•Í∏∞ÏóÖ")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå corp_codes.xml Îã§Ïö¥Î°úÎìú Ïã§Ìå®: {e}")
            return False
    
    def get_companies_from_stock_db(self) -> List[Tuple[str, str]]:
        """stock_data.dbÏóêÏÑú Ï¢ÖÎ™© Î¶¨Ïä§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞"""
        try:
            if not self.stock_db_path.exists():
                self.logger.error(f"‚ùå stock_data.dbÍ∞Ä Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§: {self.stock_db_path}")
                return []
            
            with sqlite3.connect(self.stock_db_path) as conn:
                cursor = conn.execute('''
                    SELECT stock_code, company_name 
                    FROM company_info 
                    WHERE stock_code IS NOT NULL 
                      AND stock_code != '' 
                    ORDER BY stock_code
                ''')
                
                companies = cursor.fetchall()
                company_list = [(row[0], row[1]) for row in companies]
                
                self.logger.info(f"üìã stock_data.dbÏóêÏÑú {len(company_list):,}Í∞ú Ï¢ÖÎ™© Ï°∞Ìöå ÏôÑÎ£å")
                return company_list
                
        except Exception as e:
            self.logger.error(f"‚ùå stock_data.db Ï°∞Ìöå Ïã§Ìå®: {e}")
            return []
    
    def get_financial_statements(self, corp_code: str, stock_code: str, company_name: str, year: int) -> Optional[List[Dict]]:
        """Ïû¨Î¨¥Ï†úÌëú Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞"""
        try:
            url = f"{self.base_url}/fnlttSinglAcntAll.json"
            params = {
                'crtfc_key': self.api_key,
                'corp_code': corp_code,
                'bsns_year': str(year),
                'reprt_code': '11011'  # ÏÇ¨ÏóÖÎ≥¥Í≥†ÏÑú
            }
            
            response = self.session.get(url, params=params, timeout=10)
            
            if response.status_code != 200:
                self.logger.warning(f"‚ö†Ô∏è HTTP Ïò§Î•ò {response.status_code}: {corp_code}")
                return None
            
            data = response.json()
            
            if data.get('status') == '000' and data.get('list'):
                # Í∏∞Î≥∏ Ï†ïÎ≥¥ Ï∂îÍ∞Ä
                for item in data['list']:
                    item['corp_code'] = corp_code
                    item['stock_code'] = stock_code
                    item['company_name'] = company_name
                
                return data['list']
            elif data.get('status') == '013':  # Í≤ÄÏÉâÎêú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§
                self.logger.debug(f"üì≠ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå: {company_name} ({year})")
                return None
            else:
                self.logger.warning(f"‚ö†Ô∏è API Ïò§Î•ò {data.get('status')}: {company_name} - {data.get('message')}")
                return None
                
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è API Ìò∏Ï∂ú Ïã§Ìå®: {company_name} ({year}) - {e}")
            return None
    
    def save_financial_data(self, financial_data_list: List[Dict]) -> bool:
        """Ïû¨Î¨¥Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•"""
        if not financial_data_list:
            return False
            
        try:
            with sqlite3.connect(self.dart_db_path) as conn:
                saved_count = 0
                
                for data in financial_data_list:
                    try:
                        conn.execute('''
                            INSERT OR REPLACE INTO financial_statements (
                                corp_code, stock_code, company_name, bsns_year, reprt_code,
                                account_nm, account_id, fs_div, fs_nm, sj_div, sj_nm,
                                thstrm_nm, thstrm_amount, thstrm_add_amount,
                                frmtrm_nm, frmtrm_amount, frmtrm_q_nm, frmtrm_q_amount, frmtrm_add_amount,
                                bfefrmtrm_nm, bfefrmtrm_amount, ord, currency
                            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                        ''', (
                            data.get('corp_code'), data.get('stock_code'), data.get('company_name'),
                            data.get('bsns_year'), data.get('reprt_code'),
                            data.get('account_nm'), data.get('account_id'), data.get('fs_div'), data.get('fs_nm'),
                            data.get('sj_div'), data.get('sj_nm'),
                            data.get('thstrm_nm'), data.get('thstrm_amount'), data.get('thstrm_add_amount'),
                            data.get('frmtrm_nm'), data.get('frmtrm_amount'), data.get('frmtrm_q_nm'), 
                            data.get('frmtrm_q_amount'), data.get('frmtrm_add_amount'),
                            data.get('bfefrmtrm_nm'), data.get('bfefrmtrm_amount'), data.get('ord'), data.get('currency')
                        ))
                        saved_count += 1
                    except Exception as e:
                        self.logger.debug(f"Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• Ïò§Î•ò: {e}")
                        continue
                
                conn.commit()
                
                if saved_count > 0:
                    self.logger.debug(f"‚úÖ {saved_count}Í±¥ Ï†ÄÏû• ÏôÑÎ£å")
                    return True
                
        except Exception as e:
            self.logger.error(f"‚ùå Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• Ïã§Ìå®: {e}")
            
        return False
    
    def collect_year_data(self, year: int, max_companies: Optional[int] = None) -> Dict[str, int]:
        """ÌäπÏ†ï Ïó∞ÎèÑ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë"""
        
        self.logger.info(f"üìä {year}ÎÖÑ Ïû¨Î¨¥Îç∞Ïù¥ÌÑ∞ ÏàòÏßë ÏãúÏûë")
        
        # ÌöåÏÇ¨ Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞
        companies = self.get_companies_from_stock_db()
        
        if not companies:
            self.logger.error("‚ùå ÏàòÏßëÌï† ÌöåÏÇ¨ Î™©Î°ùÏù¥ ÏóÜÏäµÎãàÎã§")
            return {'success': 0, 'fail': 0, 'records': 0}
        
        # corp_codes Îß§Ìïë Îã§Ïö¥Î°úÎìú
        if not self.download_corp_codes():
            self.logger.error("‚ùå corp_codes Îã§Ïö¥Î°úÎìú Ïã§Ìå®")
            return {'success': 0, 'fail': 0, 'records': 0}
        
        # ÏàòÏßë Ï†úÌïú
        if max_companies:
            companies = companies[:max_companies]
            self.logger.info(f"üìã ÏàòÏßë Ï†úÌïú: {len(companies):,}Í∞ú ÌöåÏÇ¨")
        
        success_count = 0
        fail_count = 0
        total_records = 0
        
        for i, (stock_code, company_name) in enumerate(companies, 1):
            try:
                # corp_code Ï∞æÍ∏∞
                if stock_code not in self.stock_to_corp_mapping:
                    self.logger.debug(f"‚ùå corp_code ÏóÜÏùå: {stock_code} {company_name}")
                    fail_count += 1
                    continue
                
                corp_info = self.stock_to_corp_mapping[stock_code]
                corp_code = corp_info['corp_code']
                
                # Ïû¨Î¨¥Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
                financial_data = self.get_financial_statements(corp_code, stock_code, company_name, year)
                
                if financial_data:
                    if self.save_financial_data(financial_data):
                        success_count += 1
                        total_records += len(financial_data)
                        self.logger.debug(f"‚úÖ {i:,}/{len(companies):,} {company_name}: {len(financial_data)}Í±¥")
                    else:
                        fail_count += 1
                        self.logger.debug(f"‚ùå Ï†ÄÏû• Ïã§Ìå®: {company_name}")
                else:
                    fail_count += 1
                    self.logger.debug(f"üì≠ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå: {company_name}")
                
                # ÏßÑÌñâÎ•† Ï∂úÎ†• (100Í∞úÎßàÎã§)
                if i % 100 == 0:
                    progress = (i / len(companies)) * 100
                    self.logger.info(f"üìä ÏßÑÌñâÎ•†: {progress:.1f}% ({success_count:,}ÏÑ±Í≥µ, {fail_count:,}Ïã§Ìå®)")
                
                # API Ï†úÌïú ÎåÄÏùë
                time.sleep(self.request_delay)
                
            except Exception as e:
                self.logger.error(f"‚ùå Ï≤òÎ¶¨ Ïã§Ìå®: {company_name} - {e}")
                fail_count += 1
                continue
        
        self.logger.info(f"‚úÖ {year}ÎÖÑ Ïû¨Î¨¥Îç∞Ïù¥ÌÑ∞ ÏàòÏßë ÏôÑÎ£å")
        self.logger.info(f"üìä ÏµúÏ¢Ö Í≤∞Í≥º: {success_count:,}/{len(companies):,}Í±¥ ÏÑ±Í≥µ ({success_count/(success_count+fail_count)*100:.1f}%)")
        
        if success_count == 0:
            self.logger.error(f"‚ùå {year}ÎÖÑ Ïû¨Î¨¥Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Ïã§Ìå®")
            self.logger.info("üí° Ìï¥Í≤∞Î∞©Ïïà: 2023ÎÖÑ Îç∞Ïù¥ÌÑ∞Î°ú ÌÖåÏä§Ìä∏Ìï¥Î≥¥ÏÑ∏Ïöî")
            self.logger.info("   python fixed_dart_collector.py --year=2023 --companies=10")
        
        return {
            'success': success_count,
            'fail': fail_count,
            'records': total_records
        }
    
    def collect_multi_year_data(self, years: List[int], max_companies: Optional[int] = None) -> bool:
        """Îã§ÎÖÑÎèÑ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë"""
        
        self.logger.info(f"üöÄ Îã§ÎÖÑÎèÑ DART ÏàòÏßë ÏãúÏûë: {years}")
        
        # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî
        if not self.init_dart_database():
            return False
        
        overall_success = 0
        overall_fail = 0
        year_results = {}
        
        for year in years:
            self.logger.info(f"\nüìÖ {year}ÎÖÑ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë ÏãúÏûë")
            
            result = self.collect_year_data(year, max_companies)
            
            year_results[year] = result
            overall_success += result['success']
            overall_fail += result['fail']
            
            self.logger.info(f"‚úÖ {year}ÎÖÑ ÏôÑÎ£å: {result['success']:,}ÏÑ±Í≥µ, {result['records']:,}Í±¥ Îç∞Ïù¥ÌÑ∞")
        
        # ÏµúÏ¢Ö Í≤∞Í≥º
        total_processed = overall_success + overall_fail
        success_rate = (overall_success / total_processed * 100) if total_processed > 0 else 0
        
        self.logger.info(f"\nüéâ Îã§ÎÖÑÎèÑ ÏàòÏßë ÏôÑÎ£å!")
        self.logger.info(f"üìä Ï†ÑÏ≤¥ Í≤∞Í≥º: {overall_success:,}/{total_processed:,} ÏÑ±Í≥µ ({success_rate:.1f}%)")
        
        for year, result in year_results.items():
            self.logger.info(f"  {year}ÎÖÑ: {result['success']:,}Í∞ú Í∏∞ÏóÖ, {result['records']:,}Í±¥ Îç∞Ïù¥ÌÑ∞")
        
        return overall_success > 0


def main():
    """Î©îÏù∏ Ïã§Ìñâ Ìï®Ïàò"""
    import argparse
    
    parser = argparse.ArgumentParser(description='ÏàòÏ†ïÎêú DART Ïû¨Î¨¥Îç∞Ïù¥ÌÑ∞ ÏàòÏßëÍ∏∞')
    parser.add_argument('--year', type=str, required=True,
                       help='ÏàòÏßëÌï† Ïó∞ÎèÑ (ÏâºÌëúÎ°ú Íµ¨Î∂Ñ, Ïòà: 2022,2023)')
    parser.add_argument('--companies', type=int,
                       help='ÏàòÏßëÌï† Í∏∞ÏóÖ Ïàò (Í∏∞Î≥∏: Ï†ÑÏ≤¥)')
    parser.add_argument('--delay', type=float, default=1.5,
                       help='ÏöîÏ≤≠ Í∞ÑÍ≤© (Ï¥à, Í∏∞Î≥∏: 1.5)')
    
    args = parser.parse_args()
    
    try:
        # Ïó∞ÎèÑ ÌååÏã±
        years = [int(year.strip()) for year in args.year.split(',')]
        
        print(f"üöÄ DART Ïû¨Î¨¥Îç∞Ïù¥ÌÑ∞ ÏàòÏßëÍ∏∞ ÏãúÏûë")
        print(f"üìÖ ÎåÄÏÉÅ Ïó∞ÎèÑ: {', '.join(map(str, years))}")
        print(f"‚è±Ô∏è API Í∞ÑÍ≤©: {args.delay}Ï¥à")
        if args.companies:
            print(f"üìä ÏàòÏßë Ï†úÌïú: {args.companies:,}Í∞ú Ï¢ÖÎ™©")
        print("=" * 60)
        
        collector = DartCollectorFixed(request_delay=args.delay)
        
        success = collector.collect_multi_year_data(
            years=years,
            max_companies=args.companies
        )
        
        if success:
            print("\n‚úÖ Îç∞Ïù¥ÌÑ∞ ÏàòÏßëÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§!")
            print("üí° Îã§Ïùå Îã®Í≥Ñ: ÏõåÎü∞ Î≤ÑÌïè Ïä§ÏΩîÏñ¥Ïπ¥Îìú Í≥ÑÏÇ∞")
        else:
            print("\n‚ùå Îç∞Ïù¥ÌÑ∞ ÏàòÏßëÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.")
            print("üí° Ìï¥Í≤∞Î∞©Ïïà:")
            print("  1. DART_API_KEY ÌôòÍ≤ΩÎ≥ÄÏàò ÌôïÏù∏")
            print("  2. 2023ÎÖÑ Îç∞Ïù¥ÌÑ∞Î°ú ÌÖåÏä§Ìä∏: --year=2023 --companies=10")
            print("  3. ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Í≤∞ ÌôïÏù∏")
            
    except KeyboardInterrupt:
        print("\nüëã ÏÇ¨Ïö©ÏûêÏóê ÏùòÌï¥ Ï§ëÎã®ÎêòÏóàÏäµÎãàÎã§.")
    except Exception as e:
        print(f"\n‚ùå Ïã§Ìñâ Ïã§Ìå®: {e}")


if __name__ == "__main__":
    main()
